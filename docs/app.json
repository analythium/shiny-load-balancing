[{"name": "app.py", "content": "# Source: https://github.com/rstudio/py-shiny/blob/7ba8f90a44ee25f41aa8c258eceeba6807e0017a/examples/load_balance/app.py\nfrom shiny import *\nimport starlette.responses\n\napp_ui = ui.page_fluid(\n    ui.markdown(\n        \"\"\"\n        ## Sticky load balancing test - Shiny for Python\n\n        The purpose of this app is to determine if HTTP requests made by the client are\n        correctly routed back to the same Python process where the session resides. It\n        is only useful for testing deployments that load balance traffic across more\n        than one Python process.\n\n        If this test fails, it means that sticky load balancing is not working, and\n        certain Shiny functionality (like file upload/download or server-side selectize)\n        are likely to randomly fail.\n        \"\"\"\n    ),\n    ui.tags.div(\n        {\"class\": \"card\"},\n        ui.tags.div(\n            {\"class\": \"card-body font-monospace\"},\n            ui.tags.div(\"Attempts: \", ui.tags.span(\"0\", id=\"count\")),\n            ui.tags.div(\"Status: \", ui.tags.span(id=\"status\")),\n            ui.output_ui(\"out\"),\n        ),\n    ),\n)\n\n\ndef server(input: Inputs, output: Outputs, session: Session):\n    @output\n    @render.ui\n    def out():\n        # Register a dynamic route for the client to try to connect to.\n        # It does nothing, just the 200 status code is all that the client\n        # will care about.\n        url = session.dynamic_route(\n            \"test\",\n            lambda req: starlette.responses.PlainTextResponse(\n                \"OK\", headers={\"Cache-Control\": \"no-cache\"}\n            ),\n        )\n\n        # Send JS code to the client to repeatedly hit the dynamic route.\n        # It will succeed if and only if we reach the correct Python\n        # process.\n        return ui.tags.script(\n            f\"\"\"\n            const url = \"{url}\";\n            const count_el = document.getElementById(\"count\");\n            const status_el = document.getElementById(\"status\");\n            let count = 0;\n            async function check_url() {{\n                count_el.innerHTML = ++count;\n                try {{\n                    const resp = await fetch(url);\n                    if (!resp.ok) {{\n                        status_el.innerHTML = \"Failure!\";\n                        return;\n                    }} else {{\n                        status_el.innerHTML = \"In progress\";\n                    }}\n                }} catch(e) {{\n                    status_el.innerHTML = \"Failure!\";\n                    return;\n                }}\n\n                if (count === 100) {{\n                    status_el.innerHTML = \"Test complete\";\n                    return;\n                }}\n\n                setTimeout(check_url, 10);\n            }}\n            check_url();\n            \"\"\"\n        )\n\n\napp = App(app_ui, server)\n", "type": "text"}, {"name": "requirements.txt", "content": "shiny>=0.2.7\n", "type": "text"}]